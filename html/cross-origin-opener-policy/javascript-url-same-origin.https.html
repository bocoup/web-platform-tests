<!DOCTYPE html>
<title>Cross-Origin-Opener-Policy and a "javascript:" URL popup</title>
<meta charset="utf-8">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="/common/utils.js"></script>

<p>According to HTML's navigate algorithm, requests to <code>javascript:</code>
URLs should inherit the cross-origin opener policy of the active document. To
observe this, each subtest uses the following procedure.</p>

<ol>
  <li>create an iframe with a given COOP (the <code>parentCOOP</code>)</li>
  <li>from the iframe, create a popup window using a <code>javascript:</code>
  URL (the new document is expected to inherit the COOP from the iframe)</li>
  <li>from the popup, create a second popup window with a given COOP (the
  <code>childCOOP</code>)</li>
</ol>

<p>Both popup windows inspect state and report back to the test context using
window postMessaging and BroadcastChannels.</p>

<pre>
    .--------------.
    |    https:    |
    |.------------.|  .-------------------.   .-----------.
    ||   https:   |-->|    javascript:    |-->|  https:   |
    || parentCOOP ||  | (COOP under test) |   | childCOOP |
    |'------------'|  '-------------------'   '-----------'
    '--------------'
</pre>

<script>
'use strict';

function setup(t, parentCOOP, childCOOP, origin, name) {
  const bc = new BroadcastChannel(name);
  const childURL = encodeURIComponent(`${origin}/html/cross-origin-opener-policy/resources/coop-coep.py?coop=${childCOOP}&coep=&channel=${name}`);

  const subjectParent = document.createElement('iframe');
  subjectParent.src =
    `/html/cross-origin-opener-policy/resources/javascript-url-same-origin.https.html` +
    `?pipe=header(cross-origin-opener-policy,${parentCOOP})` +
    `&childURL=${childURL}` +
    `&childName=${name}`;
  document.body.appendChild(subjectParent);

  t.add_cleanup(() => {
    bc.postMessage('close');
    subjectParent.contentWindow.postMessage('close', '*');
  });

  return new Promise((resolve) => {
    bc.onmessage = ({data}) => resolve(data);
  }).then(({name: childName, opener: childOpener}) => {
    return new Promise((resolve) => {
      subjectParent.contentWindow.postMessage('query', '*');
      addEventListener('message', function handle({data}) {
        if (data.channelName !== name) {
          return;
        }
        removeEventListener('message', handle);
        resolve({
          childName,
          childOpener,
          childClosed: data.childClosed,
          childURL: data.childURL
        });
      });
    });
  });
}
const { HTTPS_ORIGIN, HTTPS_REMOTE_ORIGIN } = get_host_info();

function assert_isolated(results) {
  assert_equals(results.childName, '', 'child name');
  assert_false(results.childOpener, 'child opener');
  assert_true(results.childClosed, 'child closed');
  assert_equals(results.childURL, 'about:blank');
}

function assert_not_isolated(results, expectedName) {
  assert_equals(results.childName, expectedName, 'child name');
  assert_true(results.childOpener, 'child opener');
  assert_false(results.childClosed, 'child closed');
  assert_not_equals(results.childURL, 'about:blank');
}

async_test((t) => {
  const name = token();
  setup(t, 'unsafe-none', 'unsafe-none', HTTPS_ORIGIN, name)
    .then((results) => {
      assert_not_isolated(results, name);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: same origin; parentCOOP: unsafe-none; childCOOP: unsafe-none');

async_test((t) => {
  const name = token();
  setup(t, 'unsafe-none', 'unsafe-none', HTTPS_REMOTE_ORIGIN, name)
    .then((results) => {
      assert_not_isolated(results, name);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: cross origin; parentCOOP: unsafe-none; childCOOP: unsafe-none');

async_test((t) => {
  const name = token();
  setup(t, 'same-origin', 'unsafe-none', HTTPS_ORIGIN, name)
    .then((results) => {
      assert_isolated(results);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: same origin; parentCOOP: same-origin; childCOOP: unsafe-none');

async_test((t) => {
  const name = token();
  setup(t, 'same-origin', 'unsafe-none', HTTPS_REMOTE_ORIGIN, name)
    .then((results) => {
      assert_isolated(results);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: cross origin; parentCOOP: same-origin; childCOOP: unsafe-none');

async_test((t) => {
  const name = token();
  setup(t, 'unsafe-none', 'same-origin', HTTPS_ORIGIN, name)
    .then((results) => {
      assert_isolated(results);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: same origin; parentCOOP: unsafe-none; childCOOP: same-origin');

async_test((t) => {
  const name = token();
  setup(t, 'unsafe-none', 'same-origin', HTTPS_REMOTE_ORIGIN, name)
    .then((results) => {
      assert_isolated(results);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: cross origin; parentCOOP: unsafe-none; childCOOP: same-origin');

async_test((t) => {
  const name = token();
  setup(t, 'same-origin', 'same-origin', HTTPS_ORIGIN, name)
    .then((results) => {
      assert_not_isolated(results, name);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: same origin; parentCOOP: same-origin; childCOOP: same-origin');

async_test((t) => {
  const name = token();
  setup(t, 'same-origin', 'same-origin', HTTPS_REMOTE_ORIGIN, name)
    .then((results) => {
      assert_isolated(results);
    })
    .then(t.step_func_done(), t.step_func((e) => { throw e; }));
}, 'navigation: cross origin; parentCOOP: same-origin; childCOOP: same-origin');
</script>
